<!--
 * @Author: Clark
 * @Email: haixuanwoTxh@gmail.com
 * @Date: 2024-11-11 19:29:19
 * @LastEditors: Clark
 * @LastEditTime: 2024-11-12 11:38:21
 * @Description: file content
-->

# Effective C++ 第三版 条款总结及对应代码描述

条款1: 视C++为一个语言联邦
条款2: 尽量以const、enum、inline替换#define
条款3: 尽可能使用const
条款4: 确保对象使用前已先被初始化
条款5: 了解C++默默编写并调用哪些函数
条款6: 若不想使用编译器自动生成的函数，就该明确拒绝
条款7: 为多态基类声明virtual析构函数
条款8: 别让异常逃离析构函数
条款9: 绝不在构造和析构过程中调用virtual函数
条款10: 令operator=返回一个reference to *this
条款11：在 operator= 中处理“自我赋值”
条款12：复制对象时勿忘其每一个成分
条款13：以对象管理资源
条款14：在资源管理类中小心 coping 行为
条款15：在资源管理类中提供对原始资源的访问
条款16：成对使用 new 和 delete 时要采取相同形式
条款17：以独立语句将 newed 对象置入智能指针
条款18：让接口容易被正确使用，不易被误用
条款19：设计 class 犹如设计 type，需要考虑对象创建、销毁、初始化、赋值、值传递、合法值、继承关系、转换、一般化等事项
条款20：宁以 pass-by-reference-to-const 替换 pass-by-value
条款21：必须返回对象时，别妄想返回其 reference
条款22：将成员变量声明为 private
条款23：宁以 non-member、non-friend 替换 member 函数
条款24：若所有参数皆需类型转换，请为此采用 non-member 函数
条款25：考虑写出一个不抛异常的 swap 函数
条款26：尽可能延后变量定义式的出现时间
条款27：尽量少做转型动作
条款28：避免返回 handles 指向对象内部成分
条款29：为“异常安全”而努力是值得的
条款30：透彻了解 inlining 的里里外外
条款31：将文件间的编译依存关系降至最低
条款32：继承为is a关系
条款33：避免遮掩继承而来的名称
条款34：区分接口继承和实现继承
条款35：考虑 virtual 函数以外的其他选择
条款36：绝不重新定义继承而来的 non-virtual 函数
条款37：绝不重新定义继承而来的缺省参数值
条款38：通过复合塑模出 has-a 或 “根据某物实现出”
条款39：明智而审慎地使用 private 继承
条款40：明智而审慎地使用多重继承
条款41：了解隐式接口和编译期多态
条款42：了解 typename 的双重含义
条款43：学习处理模板化基类内的名称
条款44：将与参数无关的代码抽离templates
条款45：运用成员函数模板接受所有兼容类型
条款46：需要类型转换时请为模板定义非成员函数
条款47：请使用 traits classes 表示类型信息
条款48：认识 template 元编程的两个世界
条款49：了解 new-handler 的行为
条款50：明白 new 和 delete 的合理替换时机
条款51：编写 new 和 delete 时需固守常规
条款52：写了 placement new 也要写 placement delete
条款53：不要轻忽编译器的警告
条款54：让自己熟悉包括TR1在内的标准程序库
条款55：让自己熟悉Boost
